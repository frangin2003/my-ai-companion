<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cute AI Companion</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@500;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Quicksand', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        #canvas-container {
            position: relative;
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 100px rgba(100, 180, 255, 0.15);
        }
        
        canvas {
            display: block;
            border-radius: 24px;
        }
        
        #controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 24px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 600px;
        }
        
        button {
            font-family: 'Quicksand', sans-serif;
            font-weight: 700;
            font-size: 14px;
            padding: 12px 20px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: linear-gradient(145deg, #4facfe, #00f2fe);
            color: #0a1628;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.5);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.active {
            background: linear-gradient(145deg, #f093fb, #f5576c);
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
        }
        
        #state-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 16px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="controls">
        <button data-state="idle" class="active">Idle</button>
        <button data-state="speak">Speak</button>
        <button data-state="laugh">Laugh</button>
        <button data-state="think">Think</button>
        <button data-state="sleep">Sleep</button>
        <button data-state="jump_of_joy">Jump!</button>
        <button data-state="dance">Dance</button>
        <button data-state="angry">Angry</button>
    </div>
    <div id="state-label">Current: Idle</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // ============================================
        // SCENE SETUP
        // ============================================
        const container = document.getElementById('canvas-container');
        const width = 600;
        const height = 500;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2a2a4a);

        const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
        camera.position.set(0, 1.5, 6);
        camera.lookAt(0, 0.5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // ============================================
        // LIGHTING
        // ============================================
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(5, 10, 7);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        const fillLight = new THREE.DirectionalLight(0x88ccff, 0.3);
        fillLight.position.set(-5, 5, -5);
        scene.add(fillLight);

        // ============================================
        // CHARACTER CONSTRUCTION
        // ============================================
        const character = new THREE.Group();
        scene.add(character);

        // Materials
        const whiteMat = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            roughness: 0.3,
            metalness: 0.0
        });
        const blueMat = new THREE.MeshStandardMaterial({ 
            color: 0x4facfe, 
            roughness: 0.4,
            metalness: 0.1
        });
        const blackMat = new THREE.MeshStandardMaterial({ 
            color: 0x111111, 
            roughness: 0.5 
        });
        const highlightMat = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            emissive: 0xffffff,
            emissiveIntensity: 0.5
        });
        const mouthMat = new THREE.MeshStandardMaterial({ 
            color: 0xff6b8a, 
            roughness: 0.5 
        });

        // HEAD
        const headGeom = new THREE.SphereGeometry(1, 32, 32);
        const head = new THREE.Mesh(headGeom, whiteMat);
        head.scale.set(1, 1.05, 0.95);
        head.position.y = 1.8;
        head.castShadow = true;
        character.add(head);

        // EYES
        const eyeGroup = new THREE.Group();
        eyeGroup.position.y = 1.9;
        character.add(eyeGroup);

        // Left eye
        const leftEyeGeom = new THREE.SphereGeometry(0.28, 32, 32);
        const leftEye = new THREE.Mesh(leftEyeGeom, blackMat);
        leftEye.position.set(-0.35, 0, 0.75);
        leftEye.scale.set(1, 1.2, 0.3);
        eyeGroup.add(leftEye);

        // Left eye highlight
        const leftHighlight1 = new THREE.Mesh(
            new THREE.SphereGeometry(0.08, 16, 16),
            highlightMat
        );
        leftHighlight1.position.set(-0.28, 0.12, 0.92);
        eyeGroup.add(leftHighlight1);

        const leftHighlight2 = new THREE.Mesh(
            new THREE.SphereGeometry(0.04, 16, 16),
            highlightMat
        );
        leftHighlight2.position.set(-0.4, -0.05, 0.92);
        eyeGroup.add(leftHighlight2);

        // Right eye
        const rightEye = new THREE.Mesh(leftEyeGeom, blackMat);
        rightEye.position.set(0.35, 0, 0.75);
        rightEye.scale.set(1, 1.2, 0.3);
        eyeGroup.add(rightEye);

        // Right eye highlight
        const rightHighlight1 = new THREE.Mesh(
            new THREE.SphereGeometry(0.08, 16, 16),
            highlightMat
        );
        rightHighlight1.position.set(0.42, 0.12, 0.92);
        eyeGroup.add(rightHighlight1);

        const rightHighlight2 = new THREE.Mesh(
            new THREE.SphereGeometry(0.04, 16, 16),
            highlightMat
        );
        rightHighlight2.position.set(0.3, -0.05, 0.92);
        eyeGroup.add(rightHighlight2);

        // Eyelids (for closing eyes)
        const eyelidGeom = new THREE.SphereGeometry(0.32, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        const leftEyelid = new THREE.Mesh(eyelidGeom, whiteMat);
        leftEyelid.position.set(-0.35, 0.15, 0.74);
        leftEyelid.rotation.x = Math.PI;
        leftEyelid.scale.set(1, 0, 0.4);
        eyeGroup.add(leftEyelid);

        const rightEyelid = new THREE.Mesh(eyelidGeom, whiteMat);
        rightEyelid.position.set(0.35, 0.15, 0.74);
        rightEyelid.rotation.x = Math.PI;
        rightEyelid.scale.set(1, 0, 0.4);
        eyeGroup.add(rightEyelid);

        // Eyebrows
        const eyebrowGeom = new THREE.BoxGeometry(0.25, 0.06, 0.05);
        const leftEyebrow = new THREE.Mesh(eyebrowGeom, blackMat);
        leftEyebrow.position.set(-0.35, 0.45, 0.85);
        eyeGroup.add(leftEyebrow);

        const rightEyebrow = new THREE.Mesh(eyebrowGeom, blackMat);
        rightEyebrow.position.set(0.35, 0.45, 0.85);
        eyeGroup.add(rightEyebrow);

        // MOUTH
        const mouthGroup = new THREE.Group();
        mouthGroup.position.set(0, 1.55, 0.9);
        character.add(mouthGroup);

        const mouthGeom = new THREE.SphereGeometry(0.12, 32, 32);
        const mouth = new THREE.Mesh(mouthGeom, mouthMat);
        mouth.scale.set(1.2, 0.6, 0.3);
        mouthGroup.add(mouth);

        // BODY
        const bodyGeom = new THREE.SphereGeometry(0.7, 32, 32);
        const body = new THREE.Mesh(bodyGeom, blueMat);
        body.scale.set(1, 1.2, 0.9);
        body.position.y = 0.3;
        body.castShadow = true;
        character.add(body);

        // ARMS
        const armGeom = new THREE.CapsuleGeometry(0.1, 0.4, 8, 16);
        
        const leftArmGroup = new THREE.Group();
        leftArmGroup.position.set(-0.65, 0.5, 0);
        character.add(leftArmGroup);
        
        const leftArm = new THREE.Mesh(armGeom, blueMat);
        leftArm.position.y = -0.15;
        leftArm.castShadow = true;
        leftArmGroup.add(leftArm);

        const rightArmGroup = new THREE.Group();
        rightArmGroup.position.set(0.65, 0.5, 0);
        character.add(rightArmGroup);
        
        const rightArm = new THREE.Mesh(armGeom, blueMat);
        rightArm.position.y = -0.15;
        rightArm.castShadow = true;
        rightArmGroup.add(rightArm);

        // LEGS
        const legGeom = new THREE.CapsuleGeometry(0.12, 0.3, 8, 16);
        
        const leftLeg = new THREE.Mesh(legGeom, blueMat);
        leftLeg.position.set(-0.25, -0.55, 0);
        leftLeg.castShadow = true;
        character.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeom, blueMat);
        rightLeg.position.set(0.25, -0.55, 0);
        rightLeg.castShadow = true;
        character.add(rightLeg);

        // FLOATING STAR/DIAMOND
        const starGroup = new THREE.Group();
        starGroup.position.set(0, 3.2, 0);
        character.add(starGroup);

        const starGeom = new THREE.OctahedronGeometry(0.15, 0);
        const starMat = new THREE.MeshStandardMaterial({
            color: 0x4facfe,
            emissive: 0x4facfe,
            emissiveIntensity: 0.5,
            roughness: 0.2,
            metalness: 0.8
        });
        const star = new THREE.Mesh(starGeom, starMat);
        starGroup.add(star);

        // Small glow sphere around star
        const glowGeom = new THREE.SphereGeometry(0.25, 16, 16);
        const glowMat = new THREE.MeshBasicMaterial({
            color: 0x4facfe,
            transparent: true,
            opacity: 0.2
        });
        const glow = new THREE.Mesh(glowGeom, glowMat);
        starGroup.add(glow);

        // Z's for sleep (initially hidden)
        const zGroup = new THREE.Group();
        zGroup.visible = false;
        character.add(zGroup);

        const createZ = (size, pos) => {
            const zShape = new THREE.Shape();
            zShape.moveTo(0, 0);
            zShape.lineTo(size, 0);
            zShape.lineTo(0, size);
            zShape.lineTo(size, size);
            
            const zGeom = new THREE.ShapeGeometry(zShape);
            const zMesh = new THREE.Mesh(zGeom, new THREE.MeshBasicMaterial({ 
                color: 0xaaddff,
                transparent: true,
                opacity: 0.8
            }));
            zMesh.position.copy(pos);
            return zMesh;
        };

        const z1 = createZ(0.2, new THREE.Vector3(0.8, 2.5, 0.3));
        const z2 = createZ(0.15, new THREE.Vector3(1.1, 2.8, 0.2));
        const z3 = createZ(0.1, new THREE.Vector3(1.3, 3.1, 0.1));
        zGroup.add(z1, z2, z3);

        // Floor (optional shadow catcher)
        const floorGeom = new THREE.PlaneGeometry(10, 10);
        const floorMat = new THREE.ShadowMaterial({ opacity: 0.2 });
        const floor = new THREE.Mesh(floorGeom, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.75;
        floor.receiveShadow = true;
        scene.add(floor);

        // ============================================
        // ANIMATION STATE MACHINE
        // ============================================
        let currentState = 'idle';
        let stateTime = 0;
        const clock = new THREE.Clock();

        // Store original values for resetting
        const originalPositions = {
            headY: head.position.y,
            bodyY: body.position.y,
            characterY: character.position.y,
            leftArmRotZ: 0,
            rightArmRotZ: 0,
            mouthScaleY: 0.6,
            mouthScaleX: 1.2,
            eyeScaleY: 1.2,
            eyelidScaleY: 0,
            headRotX: 0,
            headRotZ: 0,
            eyebrowY: 0.45,
            eyebrowRotZ: 0
        };

        // Reset character to default pose
        function resetPose() {
            head.position.y = originalPositions.headY;
            head.rotation.set(0, 0, 0);
            body.position.y = originalPositions.bodyY;
            body.scale.set(1, 1.2, 0.9);
            character.position.y = 0;
            character.rotation.set(0, 0, 0);
            
            leftArmGroup.rotation.z = 0;
            rightArmGroup.rotation.z = 0;
            
            mouth.scale.set(1.2, 0.6, 0.3);
            mouthGroup.position.y = 1.55;
            
            leftEye.scale.y = 1.2;
            rightEye.scale.y = 1.2;
            leftEyelid.scale.y = 0;
            rightEyelid.scale.y = 0;
            
            leftEyebrow.position.y = 0.45;
            rightEyebrow.position.y = 0.45;
            leftEyebrow.rotation.z = 0;
            rightEyebrow.rotation.z = 0;
            
            leftLeg.position.y = -0.55;
            rightLeg.position.y = -0.55;
            
            zGroup.visible = false;
        }

        // ============================================
        // ANIMATION FUNCTIONS
        // ============================================

        function animateIdle(t, delta) {
            // Subtle breathing bob
            const breathe = Math.sin(t * 2) * 0.03;
            character.position.y = breathe;
            
            // Gentle star rotation
            star.rotation.y = t * 0.5;
            star.rotation.x = Math.sin(t * 0.3) * 0.2;
            starGroup.position.y = 3.2 + Math.sin(t * 1.5) * 0.1;
            
            // Occasional blink
            const blinkCycle = t % 4;
            if (blinkCycle > 3.8 && blinkCycle < 4.0) {
                const blinkProgress = (blinkCycle - 3.8) / 0.2;
                const blinkAmount = Math.sin(blinkProgress * Math.PI);
                leftEyelid.scale.y = blinkAmount * 1.5;
                rightEyelid.scale.y = blinkAmount * 1.5;
            } else {
                leftEyelid.scale.y = 0;
                rightEyelid.scale.y = 0;
            }
        }

        function animateSpeak(t, delta) {
            // Mouth movement for speech
            const mouthOpen = (Math.sin(t * 12) + 1) * 0.5;
            const mouthWidth = 1.2 + Math.sin(t * 8) * 0.2;
            mouth.scale.set(mouthWidth, 0.3 + mouthOpen * 0.5, 0.3);
            
            // Slight head bob
            head.rotation.x = Math.sin(t * 3) * 0.05;
            head.rotation.z = Math.sin(t * 2) * 0.03;
            
            // Body sway
            character.position.y = Math.sin(t * 2) * 0.02;
            body.rotation.z = Math.sin(t * 2.5) * 0.02;
            
            // Arm gestures
            leftArmGroup.rotation.z = Math.sin(t * 2) * 0.15;
            rightArmGroup.rotation.z = -Math.sin(t * 2.3) * 0.15;
            
            // Star animation
            star.rotation.y = t * 0.8;
            starGroup.position.y = 3.2 + Math.sin(t * 3) * 0.08;
        }

        function animateLaugh(t, delta) {
            // Wide happy mouth
            mouth.scale.set(1.8, 1.0 + Math.sin(t * 15) * 0.3, 0.3);
            
            // Bouncy body
            const bounce = Math.abs(Math.sin(t * 8)) * 0.15;
            character.position.y = bounce;
            
            // Squash and stretch
            const squash = 1 + Math.sin(t * 8) * 0.1;
            body.scale.set(1 + (1 - squash) * 0.5, 1.2 * squash, 0.9);
            
            // Eyes squint with happiness
            leftEye.scale.y = 0.8;
            rightEye.scale.y = 0.8;
            leftEyelid.scale.y = 0.5;
            rightEyelid.scale.y = 0.5;
            
            // Arm movement
            leftArmGroup.rotation.z = 0.3 + Math.sin(t * 8) * 0.2;
            rightArmGroup.rotation.z = -0.3 - Math.sin(t * 8) * 0.2;
            
            // Star bounces too
            star.rotation.y = t * 2;
            starGroup.position.y = 3.2 + bounce + 0.1;
        }

        function animateThink(t, delta) {
            // Head tilt
            head.rotation.z = 0.15;
            head.rotation.x = -0.1;
            
            // Raised arm to chin
            rightArmGroup.rotation.z = -1.2;
            rightArmGroup.rotation.x = 0.3;
            
            // Slow sway
            character.position.y = Math.sin(t * 0.8) * 0.02;
            character.rotation.y = Math.sin(t * 0.5) * 0.05;
            
            // Thoughtful mouth
            mouth.scale.set(0.8, 0.4, 0.3);
            mouthGroup.position.x = 0.1;
            
            // Eyes look up
            eyeGroup.rotation.x = -0.1;
            
            // Star pulses
            star.rotation.y = t * 0.3;
            const pulse = 1 + Math.sin(t * 2) * 0.2;
            star.scale.set(pulse, pulse, pulse);
            starGroup.position.y = 3.2 + Math.sin(t) * 0.05;
        }

        function animateSleep(t, delta) {
            // Eyes closed
            leftEyelid.scale.y = 1.5;
            rightEyelid.scale.y = 1.5;
            leftEye.scale.y = 0.1;
            rightEye.scale.y = 0.1;
            
            // Small peaceful mouth
            mouth.scale.set(0.6, 0.3, 0.3);
            
            // Very gentle breathing
            const breathe = Math.sin(t * 1.5) * 0.02;
            character.position.y = breathe;
            body.scale.set(1 + breathe * 2, 1.2 - breathe, 0.9);
            
            // Head droops
            head.rotation.x = 0.1;
            head.rotation.z = Math.sin(t * 0.5) * 0.05;
            
            // Arms relaxed
            leftArmGroup.rotation.z = 0.2;
            rightArmGroup.rotation.z = -0.2;
            
            // Z's visible and floating
            zGroup.visible = true;
            z1.position.y = 2.5 + Math.sin(t * 2) * 0.1;
            z2.position.y = 2.8 + Math.sin(t * 2 + 1) * 0.1;
            z3.position.y = 3.1 + Math.sin(t * 2 + 2) * 0.1;
            z1.material.opacity = 0.5 + Math.sin(t * 3) * 0.3;
            z2.material.opacity = 0.5 + Math.sin(t * 3 + 1) * 0.3;
            z3.material.opacity = 0.5 + Math.sin(t * 3 + 2) * 0.3;
            
            // Star dims
            star.rotation.y = t * 0.2;
            starMat.emissiveIntensity = 0.2 + Math.sin(t) * 0.1;
            starGroup.position.y = 3.1;
        }

        function animateJumpOfJoy(t, delta) {
            // Jump cycle
            const jumpPhase = (t * 3) % 1;
            const jumpHeight = Math.sin(jumpPhase * Math.PI) * 0.5;
            character.position.y = jumpHeight;
            
            // Squash and stretch
            if (jumpPhase < 0.1) {
                // Anticipation squat
                body.scale.set(1.2, 1.0, 1.0);
            } else if (jumpPhase < 0.5) {
                // Stretch during rise
                body.scale.set(0.9, 1.4, 0.85);
            } else if (jumpPhase > 0.9) {
                // Land squash
                body.scale.set(1.2, 1.0, 1.0);
            } else {
                body.scale.set(1, 1.2, 0.9);
            }
            
            // Arms up!
            leftArmGroup.rotation.z = 2.5;
            rightArmGroup.rotation.z = -2.5;
            
            // Happy expression
            mouth.scale.set(1.5, 0.8, 0.3);
            leftEye.scale.y = 0.9;
            rightEye.scale.y = 0.9;
            
            // Star excited
            star.rotation.y = t * 3;
            starGroup.position.y = 3.2 + jumpHeight + 0.2;
        }

        function animateDance(t, delta) {
            // Side to side movement
            character.position.x = Math.sin(t * 4) * 0.2;
            character.position.y = Math.abs(Math.sin(t * 8)) * 0.1;
            character.rotation.z = Math.sin(t * 4) * 0.1;
            
            // Arm swing
            leftArmGroup.rotation.z = Math.sin(t * 4) * 0.5 + 0.5;
            rightArmGroup.rotation.z = -Math.sin(t * 4) * 0.5 - 0.5;
            
            // Leg movement
            leftLeg.position.y = -0.55 + Math.sin(t * 4) * 0.05;
            rightLeg.position.y = -0.55 - Math.sin(t * 4) * 0.05;
            
            // Happy face
            mouth.scale.set(1.3, 0.7 + Math.sin(t * 8) * 0.2, 0.3);
            
            // Head bob
            head.rotation.z = Math.sin(t * 4) * 0.1;
            head.rotation.y = Math.sin(t * 2) * 0.1;
            
            // Star dances too
            star.rotation.y = t * 2;
            starGroup.position.x = Math.sin(t * 4) * 0.1;
            starGroup.position.y = 3.2 + Math.abs(Math.sin(t * 8)) * 0.15;
        }

        function animateAngry(t, delta) {
            // Angry eyebrows
            leftEyebrow.position.y = 0.35;
            rightEyebrow.position.y = 0.35;
            leftEyebrow.rotation.z = 0.3;
            rightEyebrow.rotation.z = -0.3;
            
            // Angry mouth
            mouth.scale.set(1.0, 0.3, 0.3);
            mouthGroup.position.y = 1.5;
            
            // Shaking
            const shake = Math.sin(t * 30) * 0.02;
            character.position.x = shake;
            character.rotation.z = shake * 0.5;
            
            // Tense body
            body.scale.set(1.05, 1.15, 0.95);
            
            // Fists clenched at sides
            leftArmGroup.rotation.z = 0.3;
            rightArmGroup.rotation.z = -0.3;
            
            // Eyes narrowed
            leftEyelid.scale.y = 0.4;
            rightEyelid.scale.y = 0.4;
            
            // Star turns red-ish and spins fast
            star.rotation.y = t * 4;
            starMat.color.setHex(0xff6666);
            starMat.emissive.setHex(0xff4444);
            starGroup.position.y = 3.2 + Math.sin(t * 10) * 0.05;
        }

        // ============================================
        // MAIN ANIMATION LOOP
        // ============================================
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            stateTime += delta;
            
            // Reset pose before applying state animation
            resetPose();
            
            // Reset star color (in case of angry state)
            if (currentState !== 'angry') {
                starMat.color.setHex(0x4facfe);
                starMat.emissive.setHex(0x4facfe);
                starMat.emissiveIntensity = 0.5;
            }
            
            // Reset mouth position
            mouthGroup.position.x = 0;
            
            // Reset eye group
            eyeGroup.rotation.x = 0;
            
            // Apply current state animation
            switch (currentState) {
                case 'idle':
                    animateIdle(stateTime, delta);
                    break;
                case 'speak':
                    animateSpeak(stateTime, delta);
                    break;
                case 'laugh':
                    animateLaugh(stateTime, delta);
                    break;
                case 'think':
                    animateThink(stateTime, delta);
                    break;
                case 'sleep':
                    animateSleep(stateTime, delta);
                    break;
                case 'jump_of_joy':
                    animateJumpOfJoy(stateTime, delta);
                    break;
                case 'dance':
                    animateDance(stateTime, delta);
                    break;
                case 'angry':
                    animateAngry(stateTime, delta);
                    break;
            }
            
            renderer.render(scene, camera);
        }

        // ============================================
        // UI CONTROLS
        // ============================================
        const buttons = document.querySelectorAll('button[data-state]');
        const stateLabel = document.getElementById('state-label');

        buttons.forEach(button => {
            button.addEventListener('click', () => {
                const newState = button.dataset.state;
                currentState = newState;
                stateTime = 0; // Reset animation time
                
                // Update active button
                buttons.forEach(b => b.classList.remove('active'));
                button.classList.add('active');
                
                // Update label
                const stateName = newState.replace('_', ' ').replace(/\b\w/g, c => c.toUpperCase());
                stateLabel.textContent = `Current: ${stateName}`;
            });
        });

        // Start animation
        animate();

        // ============================================
        // WINDOW RESIZE HANDLER
        // ============================================
        window.addEventListener('resize', () => {
            // Keep fixed size for consistent appearance
        });

    </script>
</body>
</html>