<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Companion Avatar</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #canvas-container {
            width: 100%;
            height: calc(100vh - 100px);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90%;
            padding: 15px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        button {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="controls">
        <button onclick="setState('idle')">Idle</button>
        <button onclick="setState('speak')">Speak</button>
        <button onclick="setState('laugh')">Laugh</button>
        <button onclick="setState('think')">Think</button>
        <button onclick="setState('sleep')">Sleep</button>
        <button onclick="setState('jump_of_joy')">Jump of Joy</button>
        <button onclick="setState('dance')">Dance</button>
        <button onclick="setState('angry')">Angry</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r124/three.min.js"></script>
    <script>
        // ==================== SCENE SETUP ====================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f5);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 8);
        camera.lookAt(0, 2, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight - 100);
        renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
        fillLight.position.set(-5, 5, -5);
        scene.add(fillLight);
        
        // ==================== CHARACTER CONSTRUCTION ====================
        const character = new THREE.Group();
        
        // Head (white, round)
        const headGeometry = new THREE.SphereGeometry(0.8, 32, 32);
        const headMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 2.5;
        head.castShadow = true;
        character.add(head);
        
        // Left Eye
        const eyeGeometry = new THREE.SphereGeometry(0.18, 16, 16);
        const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.25, 2.6, 0.65);
        character.add(leftEye);
        
        // Left Eye Highlight
        const highlightGeometry = new THREE.SphereGeometry(0.06, 8, 8);
        const highlightMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
        const leftHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
        leftHighlight.position.set(-0.2, 2.65, 0.72);
        character.add(leftHighlight);
        
        // Right Eye
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.25, 2.6, 0.65);
        character.add(rightEye);
        
        // Right Eye Highlight
        const rightHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
        rightHighlight.position.set(0.3, 2.65, 0.72);
        character.add(rightHighlight);
        
        // Eyelids (for sleep state)
        const eyelidGeometry = new THREE.SphereGeometry(0.19, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        const eyelidMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
        const leftEyelid = new THREE.Mesh(eyelidGeometry, eyelidMaterial);
        leftEyelid.position.set(-0.25, 2.6, 0.65);
        leftEyelid.rotation.x = Math.PI;
        leftEyelid.visible = false;
        character.add(leftEyelid);
        
        const rightEyelid = new THREE.Mesh(eyelidGeometry, eyelidMaterial);
        rightEyelid.position.set(0.25, 2.6, 0.65);
        rightEyelid.rotation.x = Math.PI;
        rightEyelid.visible = false;
        character.add(rightEyelid);
        
        // Mouth (small sphere that we'll deform)
        const mouthGeometry = new THREE.SphereGeometry(0.12, 16, 16, 0, Math.PI * 2, 0, Math.PI);
        const mouthMaterial = new THREE.MeshPhongMaterial({ color: 0xff6b9d });
        const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
        mouth.position.set(0, 2.2, 0.7);
        mouth.rotation.x = Math.PI;
        character.add(mouth);
        
        // Body (egg-shaped blue)
        const bodyGeometry = new THREE.SphereGeometry(0.6, 32, 32);
        bodyGeometry.scale(1, 1.3, 0.9);
        const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x5BA3F5 });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 1.2;
        body.castShadow = true;
        character.add(body);
        
        // Left Arm
        const armGeometry = new THREE.CapsuleGeometry(0.08, 0.4, 8, 16);
        const armMaterial = new THREE.MeshPhongMaterial({ color: 0x5BA3F5 });
        const leftArm = new THREE.Mesh(armGeometry, armMaterial);
        leftArm.position.set(-0.5, 1.2, 0);
        leftArm.rotation.z = 0.3;
        character.add(leftArm);
        
        // Right Arm
        const rightArm = new THREE.Mesh(armGeometry, armMaterial);
        rightArm.position.set(0.5, 1.2, 0);
        rightArm.rotation.z = -0.3;
        character.add(rightArm);
        
        // Left Leg
        const legGeometry = new THREE.CapsuleGeometry(0.1, 0.3, 8, 16);
        const legMaterial = new THREE.MeshPhongMaterial({ color: 0x5BA3F5 });
        const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
        leftLeg.position.set(-0.2, 0.4, 0);
        character.add(leftLeg);
        
        // Right Leg
        const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
        rightLeg.position.set(0.2, 0.4, 0);
        character.add(rightLeg);
        
        // Floating Diamond/Star
        const diamondGeometry = new THREE.OctahedronGeometry(0.15, 0);
        const diamondMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x5BA3F5,
            emissive: 0x5BA3F5,
            emissiveIntensity: 0.3
        });
        const diamond = new THREE.Mesh(diamondGeometry, diamondMaterial);
        diamond.position.y = 3.6;
        character.add(diamond);
        
        // Sleep Z (hidden by default)
        const zGeometry = new THREE.TorusGeometry(0.1, 0.03, 8, 16);
        const zMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
        const sleepZ = new THREE.Mesh(zGeometry, zMaterial);
        sleepZ.position.set(0.8, 3.2, 0);
        sleepZ.visible = false;
        character.add(sleepZ);
        
        scene.add(character);
        
        // ==================== ANIMATION STATE SYSTEM ====================
        let currentState = 'idle';
        let animationTime = 0;
        const clock = new THREE.Clock();
        
        // Store original positions/rotations
        const originalPositions = {
            head: head.position.clone(),
            body: body.position.clone(),
            leftArm: leftArm.position.clone(),
            rightArm: rightArm.position.clone(),
            mouth: mouth.position.clone(),
            leftEye: leftEye.position.clone(),
            rightEye: rightEye.position.clone(),
            character: character.position.clone()
        };
        
        const originalRotations = {
            head: head.rotation.clone(),
            leftArm: leftArm.rotation.clone(),
            rightArm: rightArm.rotation.clone()
        };
        
        const originalScales = {
            mouth: mouth.scale.clone(),
            leftEye: leftEye.scale.clone(),
            rightEye: rightEye.scale.clone()
        };
        
        // ==================== STATE FUNCTIONS ====================
        function resetToNeutral() {
            head.position.copy(originalPositions.head);
            body.position.copy(originalPositions.body);
            leftArm.position.copy(originalPositions.leftArm);
            rightArm.position.copy(originalPositions.rightArm);
            mouth.position.copy(originalPositions.mouth);
            leftEye.position.copy(originalPositions.leftEye);
            rightEye.position.copy(originalPositions.rightEye);
            character.position.copy(originalPositions.character);
            
            head.rotation.copy(originalRotations.head);
            leftArm.rotation.copy(originalRotations.leftArm);
            rightArm.rotation.copy(originalRotations.rightArm);
            
            mouth.scale.copy(originalScales.mouth);
            leftEye.scale.copy(originalScales.leftEye);
            rightEye.scale.copy(originalScales.rightEye);
            
            leftEyelid.visible = false;
            rightEyelid.visible = false;
            leftEye.visible = true;
            rightEye.visible = true;
            leftHighlight.visible = true;
            rightHighlight.visible = true;
            sleepZ.visible = false;
            
            mouthMaterial.color.setHex(0xff6b9d);
        }
        
        function animateIdle(delta) {
            const breathe = Math.sin(animationTime * 2) * 0.03;
            body.position.y = originalPositions.body.y + breathe;
            head.position.y = originalPositions.head.y + breathe;
            diamond.rotation.y += delta * 0.5;
        }
        
        function animateSpeak(delta) {
            // Breathing
            const breathe = Math.sin(animationTime * 3) * 0.02;
            body.position.y = originalPositions.body.y + breathe;
            head.position.y = originalPositions.head.y + breathe;
            
            // Talking mouth animation - cycle through shapes
            const talkCycle = Math.sin(animationTime * 8);
            mouth.scale.set(
                1 + Math.abs(talkCycle) * 0.5,
                1 + Math.abs(talkCycle) * 0.8,
                1
            );
            mouth.position.y = originalPositions.mouth.y + Math.abs(talkCycle) * 0.05;
            
            // Slight head bob
            head.rotation.z = Math.sin(animationTime * 4) * 0.05;
            diamond.rotation.y += delta * 0.8;
        }
        
        function animateLaugh(delta) {
            // Happy mouth
            mouth.scale.set(1.8, 0.5, 1);
            
            // Enthusiastic bobbing
            const bob = Math.sin(animationTime * 5) * 0.15;
            body.position.y = originalPositions.body.y + Math.abs(bob);
            head.position.y = originalPositions.head.y + Math.abs(bob);
            
            // Tilting head
            head.rotation.z = Math.sin(animationTime * 5) * 0.15;
            
            // Arms moving
            leftArm.rotation.z = 0.3 + Math.sin(animationTime * 5) * 0.3;
            rightArm.rotation.z = -0.3 - Math.sin(animationTime * 5) * 0.3;
            
            diamond.rotation.y += delta * 1.5;
        }
        
        function animateThink(delta) {
            // Head tilt
            head.rotation.z = 0.3;
            head.rotation.x = -0.2;
            
            // One arm raised
            rightArm.position.y = originalPositions.rightArm.y + 0.5;
            rightArm.rotation.z = -1.5;
            
            // Slow breathing
            const breathe = Math.sin(animationTime * 1.5) * 0.02;
            body.position.y = originalPositions.body.y + breathe;
            
            // Small mouth
            mouth.scale.set(0.7, 0.7, 1);
            
            diamond.rotation.y += delta * 0.3;
        }
        
        function animateSleep(delta) {
            // Eyes closed
            leftEyelid.visible = true;
            rightEyelid.visible = true;
            leftHighlight.visible = false;
            rightHighlight.visible = false;
            
            // Very gentle breathing
            const breathe = Math.sin(animationTime * 1) * 0.05;
            body.position.y = originalPositions.body.y + breathe;
            head.position.y = originalPositions.head.y + breathe;
            
            // Head tilted
            head.rotation.z = 0.4;
            
            // Small closed mouth
            mouth.scale.set(0.5, 0.3, 1);
            
            // Show Z
            sleepZ.visible = true;
            sleepZ.position.y = 3.2 + Math.sin(animationTime * 2) * 0.1;
            sleepZ.rotation.z = animationTime * 0.5;
            
            diamond.rotation.y += delta * 0.2;
        }
        
        function animateJumpOfJoy(delta) {
            // Hopping motion with squash and stretch
            const jumpPhase = (animationTime * 4) % (Math.PI * 2);
            const jumpHeight = Math.max(0, Math.sin(jumpPhase)) * 0.8;
            
            character.position.y = originalPositions.character.y + jumpHeight;
            
            // Squash and stretch
            const squash = jumpHeight > 0.1 ? 1.2 : 0.9;
            body.scale.set(1 / Math.sqrt(squash), squash, 1 / Math.sqrt(squash));
            
            // Arms raised
            leftArm.rotation.z = 0.3 + 0.8;
            rightArm.rotation.z = -0.3 - 0.8;
            leftArm.position.y = originalPositions.leftArm.y + 0.3;
            rightArm.position.y = originalPositions.rightArm.y + 0.3;
            
            // Happy mouth
            mouth.scale.set(1.5, 0.6, 1);
            
            diamond.rotation.y += delta * 2;
        }
        
        function animateDance(delta) {
            // Side to side motion
            const sway = Math.sin(animationTime * 3);
            character.rotation.y = sway * 0.3;
            
            // Body and head bob
            const bob = Math.abs(Math.sin(animationTime * 3)) * 0.1;
            body.position.y = originalPositions.body.y + bob;
            head.position.y = originalPositions.head.y + bob;
            
            // Arms alternating
            leftArm.rotation.z = 0.3 + Math.sin(animationTime * 3) * 0.5;
            rightArm.rotation.z = -0.3 - Math.sin(animationTime * 3 + Math.PI) * 0.5;
            
            // Happy mouth
            mouth.scale.set(1.3, 0.7, 1);
            
            diamond.rotation.y += delta * 1.2;
            diamond.position.y = 3.6 + Math.sin(animationTime * 3) * 0.1;
        }
        
        function animateAngry(delta) {
            // Angry eyebrows (squash eyes to look angry)
            leftEye.scale.set(1, 0.7, 1);
            rightEye.scale.set(1, 0.7, 1);
            leftEye.position.y = originalPositions.leftEye.y - 0.05;
            rightEye.position.y = originalPositions.rightEye.y - 0.05;
            
            // Frown
            mouth.scale.set(1.2, 0.4, 1);
            mouth.rotation.x = Math.PI + 0.3;
            mouthMaterial.color.setHex(0xff4444);
            
            // Shaking
            const shake = Math.sin(animationTime * 20) * 0.02;
            head.position.x = shake;
            body.position.x = shake;
            
            // Tense arms
            leftArm.rotation.z = 0.5;
            rightArm.rotation.z = -0.5;
            
            diamond.rotation.y += delta * 1.0;
            diamond.rotation.x = Math.sin(animationTime * 5) * 0.2;
        }
        
        // ==================== MAIN ANIMATION LOOP ====================
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            animationTime += delta;
            
            // Reset to neutral before applying state
            resetToNeutral();
            
            // Apply current state animation
            switch(currentState) {
                case 'idle':
                    animateIdle(delta);
                    break;
                case 'speak':
                    animateSpeak(delta);
                    break;
                case 'laugh':
                    animateLaugh(delta);
                    break;
                case 'think':
                    animateThink(delta);
                    break;
                case 'sleep':
                    animateSleep(delta);
                    break;
                case 'jump_of_joy':
                    animateJumpOfJoy(delta);
                    break;
                case 'dance':
                    animateDance(delta);
                    break;
                case 'angry':
                    animateAngry(delta);
                    break;
            }
            
            renderer.render(scene, camera);
        }
        
        // ==================== STATE CONTROL ====================
        function setState(newState) {
            currentState = newState;
            animationTime = 0;
            body.scale.set(1, 1, 1); // Reset any squash/stretch
            character.rotation.y = 0; // Reset rotation
            
            // Update button states
            const buttons = document.querySelectorAll('button');
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }
        
        // Make setState global
        window.setState = setState;
        
        // ==================== WINDOW RESIZE ====================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight - 100);
        });
        
        // ==================== START ====================
        // Set initial button state
        document.querySelector('button').classList.add('active');
        animate();
    </script>
</body>
</html>