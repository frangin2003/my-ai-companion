<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Kawaii AI Companion</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #ffffff, #dfe6ff 70%);
      font-family: "Segoe UI", "Nunito", system-ui, -apple-system, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2.5rem 1.25rem 3rem;
      color: #1b2754;
    }
    #canvas-container {
      width: min(92vw, 960px);
      height: clamp(440px, 62vh, 640px);
      border-radius: 36px;
      background: linear-gradient(145deg, #fafbff, #e0e7ff);
      box-shadow: 0 30px 80px rgba(54, 76, 153, 0.3);
      overflow: hidden;
    }
    canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }
    #controls {
      width: min(95vw, 960px);
      margin-top: 1.75rem;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.65rem;
    }
    button {
      border: 0;
      border-radius: 999px;
      padding: 0.65rem 1.25rem;
      font-size: 0.95rem;
      font-weight: 600;
      color: #1d2b4f;
      background: #ffffff;
      box-shadow: 0 10px 25px rgba(56, 84, 150, 0.18);
      cursor: pointer;
      transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
    }
    button:hover {
      transform: translateY(-2px);
    }
    button.active {
      background: linear-gradient(135deg, #5f8fff, #7fb0ff);
      color: #ffffff;
      box-shadow: 0 15px 35px rgba(87, 121, 226, 0.4);
    }
    @media (max-width: 600px) {
      button {
        flex: 1 1 45%;
        text-align: center;
      }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div id="controls">
    <button data-state="idle" class="active">Idle</button>
    <button data-state="speak">Speak</button>
    <button data-state="laugh">Laugh</button>
    <button data-state="think">Think</button>
    <button data-state="sleep">Sleep</button>
    <button data-state="jump_of_joy">Jump of Joy</button>
    <button data-state="dance">Dance</button>
    <button data-state="angry">Angry</button>
  </div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161/build/three.module.js';

    // Scene setup
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf2f5ff);

    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    camera.position.set(0, 1.2, 4);
    camera.lookAt(0, 0.9, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.85);
    scene.add(ambientLight);

    const keyLight = new THREE.DirectionalLight(0xffffff, 0.9);
    keyLight.position.set(3, 5, 4);
    scene.add(keyLight);

    const rimLight = new THREE.DirectionalLight(0xaec8ff, 0.5);
    rimLight.position.set(-4, 2.5, -3);
    scene.add(rimLight);

    const ground = new THREE.Mesh(
      new THREE.CircleGeometry(3.3, 48),
      new THREE.MeshStandardMaterial({ color: 0xdfe5ff, roughness: 0.95 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.65;
    scene.add(ground);

    // Character construction
    const avatar = new THREE.Group();
    scene.add(avatar);

    const headMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 0.3,
      metalness: 0.1
    });
    const bodyMaterial = new THREE.MeshStandardMaterial({
      color: 0x4f8bff,
      roughness: 0.4,
      metalness: 0.08
    });
    const armMaterial = new THREE.MeshStandardMaterial({
      color: 0xaec6ff,
      roughness: 0.45
    });
    const legMaterial = new THREE.MeshStandardMaterial({
      color: 0x365dcc,
      roughness: 0.5
    });

    const baseColors = {
      body: bodyMaterial.color.getHex(),
      arm: armMaterial.color.getHex()
    };

    const head = new THREE.Mesh(new THREE.SphereGeometry(0.94, 48, 48), headMaterial);
    head.position.y = 1.35;
    head.scale.set(1, 1.03, 1);
    avatar.add(head);

    const body = new THREE.Mesh(new THREE.SphereGeometry(0.72, 48, 48), bodyMaterial);
    body.position.y = 0.35;
    body.scale.set(1, 1.2, 1);
    avatar.add(body);

    const eyeGeometry = new THREE.SphereGeometry(0.22, 32, 32);
    const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.25 });

    function createEye(side = 1) {
      const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      eye.scale.set(0.55, 0.82, 0.45);
      eye.position.set(side * 0.32, 0.22, 0.77);
      const highlight = new THREE.Mesh(
        new THREE.SphereGeometry(0.06, 12, 12),
        new THREE.MeshBasicMaterial({ color: 0xffffff })
      );
      highlight.position.set(-0.07 * side, 0.08, 0.12);
      eye.add(highlight);
      head.add(eye);
      return eye;
    }

    const leftEye = createEye(-1);
    const rightEye = createEye(1);
    const eyes = [leftEye, rightEye];
    const eyeBaseScale = leftEye.scale.clone();

    const mouth = new THREE.Mesh(
      new THREE.PlaneGeometry(0.45, 0.22),
      new THREE.MeshStandardMaterial({
        color: 0x111111,
        roughness: 0.2,
        metalness: 0.05,
        side: THREE.DoubleSide
      })
    );
    mouth.position.set(0, -0.18, 0.82);
    head.add(mouth);

    const mouthBaseY = mouth.position.y;
    const mouthBaseScale = mouth.scale.clone();

    const browGeometry = new THREE.BoxGeometry(0.36, 0.05, 0.05);
    const browMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4 });
    const leftBrow = new THREE.Mesh(browGeometry, browMaterial);
    leftBrow.position.set(-0.32, 0.52, 0.78);
    leftBrow.rotation.z = 0.12;
    head.add(leftBrow);
    const rightBrow = new THREE.Mesh(browGeometry, browMaterial);
    rightBrow.position.set(0.32, 0.52, 0.78);
    rightBrow.rotation.z = -0.12;
    head.add(rightBrow);

    const browBase = {
      left: { rotation: leftBrow.rotation.z, y: leftBrow.position.y },
      right: { rotation: rightBrow.rotation.z, y: rightBrow.position.y }
    };

    const diamondPivot = new THREE.Group();
    diamondPivot.position.y = 2.25;
    avatar.add(diamondPivot);

    const diamond = new THREE.Mesh(
      new THREE.OctahedronGeometry(0.14),
      new THREE.MeshStandardMaterial({
        color: 0x6fd4ff,
        emissive: 0x2784d0,
        emissiveIntensity: 0.55,
        metalness: 0.2,
        roughness: 0.3
      })
    );
    diamondPivot.add(diamond);

    const halo = new THREE.Mesh(
      new THREE.RingGeometry(0.18, 0.24, 24),
      new THREE.MeshBasicMaterial({ color: 0xcfe7ff, side: THREE.DoubleSide })
    );
    halo.rotation.x = Math.PI / 2;
    halo.position.y = 0.22;
    diamondPivot.add(halo);
    const diamondBaseY = diamondPivot.position.y;

    function createArm(side = 1) {
      const group = new THREE.Group();
      const limb = new THREE.Mesh(new THREE.CapsuleGeometry(0.07, 0.26, 6, 18), armMaterial);
      limb.position.y = -0.17;
      group.add(limb);
      group.position.set(side * 0.78, 0.72, 0.08);
      group.rotation.z = side * -0.35;
      return group;
    }

    function createLeg(side = 1) {
      const group = new THREE.Group();
      const limb = new THREE.Mesh(new THREE.CapsuleGeometry(0.09, 0.22, 6, 18), legMaterial);
      limb.position.y = -0.2;
      group.add(limb);
      group.position.set(side * 0.32, -0.4, 0.1);
      group.rotation.x = 0.15;
      return group;
    }

    const leftArm = createArm(-1);
    const rightArm = createArm(1);
    avatar.add(leftArm, rightArm);

    const leftLeg = createLeg(-1);
    const rightLeg = createLeg(1);
    avatar.add(leftLeg, rightLeg);

    const leftArmBaseRot = leftArm.rotation.clone();
    const rightArmBaseRot = rightArm.rotation.clone();
    const leftArmBasePos = leftArm.position.clone();
    const rightArmBasePos = rightArm.position.clone();
    const leftLegBaseRot = leftLeg.rotation.clone();
    const rightLegBaseRot = rightLeg.rotation.clone();

    function buildZSymbol(scale = 1) {
      const group = new THREE.Group();
      const mat = new THREE.MeshStandardMaterial({
        color: 0xbdd5ff,
        emissive: 0x214078,
        emissiveIntensity: 0.35
      });
      const top = new THREE.Mesh(new THREE.BoxGeometry(0.38 * scale, 0.06 * scale, 0.05), mat);
      top.position.y = 0.12 * scale;
      group.add(top);
      const bottom = new THREE.Mesh(new THREE.BoxGeometry(0.38 * scale, 0.06 * scale, 0.05), mat);
      bottom.position.y = -0.12 * scale;
      group.add(bottom);
      const diag = new THREE.Mesh(new THREE.BoxGeometry(0.48 * scale, 0.06 * scale, 0.05), mat);
      diag.rotation.z = -Math.PI / 8;
      group.add(diag);
      return group;
    }

    const sleepZGroup = new THREE.Group();
    const zOne = buildZSymbol(1);
    zOne.position.set(0.1, 2.0, 0.4);
    zOne.userData = { baseX: zOne.position.x, baseY: zOne.position.y };
    const zTwo = buildZSymbol(0.7);
    zTwo.position.set(0.4, 2.5, 0.5);
    zTwo.userData = { baseX: zTwo.position.x, baseY: zTwo.position.y };
    sleepZGroup.add(zOne, zTwo);
    sleepZGroup.visible = false;
    scene.add(sleepZGroup);

    // Helpers for expressions
    function setEyeOpenness(value) {
      const openness = THREE.MathUtils.clamp(value, 0.1, 1.4);
      eyes.forEach((eye) => {
        eye.scale.y = eyeBaseScale.y * openness;
        eye.scale.x = eyeBaseScale.x * (1 + (1 - openness) * 0.25);
      });
    }

    function setMouthShape({ width = 1, height = 1, offsetY = 0, rotation = 0 }) {
      mouth.scale.x = mouthBaseScale.x * width;
      mouth.scale.y = mouthBaseScale.y * height;
      mouth.position.y = mouthBaseY + offsetY;
      mouth.rotation.z = rotation;
    }

    function setBrowMood(intensity) {
      const t = THREE.MathUtils.clamp(intensity, 0, 1);
      leftBrow.rotation.z = THREE.MathUtils.lerp(browBase.left.rotation, -0.65, t);
      rightBrow.rotation.z = THREE.MathUtils.lerp(browBase.right.rotation, 0.65, t);
      leftBrow.position.y = browBase.left.y + t * 0.05;
      rightBrow.position.y = browBase.right.y + t * 0.05;
    }

    function resetPose() {
      avatar.position.set(0, 0, 0);
      avatar.position.x = 0;
      avatar.rotation.set(0, 0, 0);
      avatar.scale.set(1, 1, 1);

      head.rotation.set(0, 0, 0);
      setEyeOpenness(1);
      setMouthShape({ width: 0.9, height: 0.4, offsetY: -0.02, rotation: 0 });
      setBrowMood(0);

      leftArm.rotation.set(leftArmBaseRot.x, leftArmBaseRot.y, leftArmBaseRot.z);
      rightArm.rotation.set(rightArmBaseRot.x, rightArmBaseRot.y, rightArmBaseRot.z);
      leftArm.position.copy(leftArmBasePos);
      rightArm.position.copy(rightArmBasePos);

      leftLeg.rotation.set(leftLegBaseRot.x, leftLegBaseRot.y, leftLegBaseRot.z);
      rightLeg.rotation.set(rightLegBaseRot.x, rightLegBaseRot.y, rightLegBaseRot.z);

      bodyMaterial.color.setHex(baseColors.body);
      armMaterial.color.setHex(baseColors.arm);
    }

    // Animation state machine
    const clock = new THREE.Clock();
    let stateTime = 0;
    let currentState = 'idle';

    const buttons = document.querySelectorAll('#controls button');
    function setState(state) {
      currentState = state;
      stateTime = 0;
      buttons.forEach((btn) => btn.classList.toggle('active', btn.dataset.state === state));
    }
    buttons.forEach((btn) =>
      btn.addEventListener('click', () => {
        setState(btn.dataset.state);
      })
    );
    setState('idle');

    function resizeRenderer() {
      const { clientWidth, clientHeight } = container;
      renderer.setSize(clientWidth, clientHeight, false);
      camera.aspect = clientWidth / clientHeight;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resizeRenderer);
    resizeRenderer();

    function updateSleepSymbols(elapsed) {
      sleepZGroup.children.forEach((symbol, index) => {
        symbol.position.y = symbol.userData.baseY + Math.sin(elapsed * 1.2 + index) * 0.12;
        symbol.position.x = symbol.userData.baseX + Math.cos(elapsed * 1.3 + index) * 0.06;
        symbol.rotation.z = Math.sin(elapsed * 1.4 + index) * 0.4;
      });
      sleepZGroup.visible = currentState === 'sleep';
    }

    function updateAnimation(delta) {
      const elapsed = clock.elapsedTime;
      resetPose();

      diamondPivot.position.y = diamondBaseY + Math.sin(elapsed * 3) * 0.05;
      diamondPivot.rotation.y += delta * 1.6;
      halo.rotation.z += delta * 0.8;

      updateSleepSymbols(elapsed);

      switch (currentState) {
        case 'idle': {
          const bob = Math.sin(elapsed * 2) * 0.05;
          avatar.position.y = bob;
          setMouthShape({ width: 0.9, height: 0.4, offsetY: -0.01 });
          break;
        }
        case 'speak': {
          const talk = (Math.sin(stateTime * 10) + 1) * 0.5;
          avatar.position.y = Math.sin(stateTime * 5) * 0.05;
          head.rotation.z = Math.sin(stateTime * 3) * 0.07;
          leftArm.rotation.z = leftArmBaseRot.z + Math.sin(stateTime * 4) * 0.08;
          rightArm.rotation.z = rightArmBaseRot.z - Math.sin(stateTime * 4) * 0.08;
          setMouthShape({
            width: 0.85 + Math.sin(stateTime * 4) * 0.18,
            height: 0.35 + talk * 1.0,
            offsetY: -0.02 + talk * 0.05
          });
          break;
        }
        case 'laugh': {
          const bounce = Math.abs(Math.sin(stateTime * 4));
          avatar.position.y = bounce * 0.2;
          head.rotation.x = -0.08 + bounce * 0.08;
          setEyeOpenness(0.55);
          setMouthShape({ width: 1.4, height: 1.2, offsetY: 0.08 });
          leftArm.rotation.z = leftArmBaseRot.z - 0.2;
          rightArm.rotation.z = rightArmBaseRot.z + 0.2;
          break;
        }
        case 'think': {
          avatar.position.y = Math.sin(stateTime * 1.5) * 0.03;
          head.rotation.z = 0.35 + Math.sin(stateTime * 0.8) * 0.05;
          setEyeOpenness(0.85);
          setMouthShape({ width: 0.6, height: 0.3, offsetY: -0.05 });
          leftArm.rotation.z = -Math.PI / 2.2;
          leftArm.rotation.x = 0.9;
          leftArm.position.y = leftArmBasePos.y + 0.25;
          leftArm.position.x = leftArmBasePos.x + 0.1;
          break;
        }
        case 'sleep': {
          const bob = Math.sin(stateTime * 1.3) * 0.02;
          avatar.position.y = bob - 0.05;
          head.rotation.x = 0.25;
          setEyeOpenness(0.12);
          setMouthShape({ width: 0.5, height: 0.2, offsetY: -0.06 });
          leftArm.rotation.z = leftArmBaseRot.z + 0.3;
          rightArm.rotation.z = rightArmBaseRot.z - 0.3;
          break;
        }
        case 'jump_of_joy': {
          const hop = Math.max(Math.sin(stateTime * 4), 0);
          avatar.position.y = hop * 0.5;
          avatar.scale.y = 1 - hop * 0.12;
          avatar.scale.x = 1 + hop * 0.08;
          head.rotation.x = -hop * 0.2;
          setMouthShape({ width: 1.1, height: 0.75, offsetY: 0.02 });
          leftArm.rotation.x = -1.2;
          leftArm.rotation.z = 0;
          rightArm.rotation.x = -1.2;
          rightArm.rotation.z = 0;
          leftLeg.rotation.x = leftLegBaseRot.x + hop * 0.2;
          rightLeg.rotation.x = rightLegBaseRot.x + hop * 0.2;
          break;
        }
        case 'dance': {
          const sway = Math.sin(stateTime * 4);
          avatar.position.x = sway * 0.3;
          avatar.position.y = Math.abs(Math.cos(stateTime * 2)) * 0.12;
          avatar.rotation.y = Math.sin(stateTime * 2) * 0.1;
          head.rotation.z = sway * 0.2;
          leftArm.rotation.z = -0.2 + Math.sin(stateTime * 4) * 0.5;
          rightArm.rotation.z = 0.2 - Math.sin(stateTime * 4) * 0.5;
          setMouthShape({ width: 1.0, height: 0.6, offsetY: 0.03 });
          break;
        }
        case 'angry': {
          const shake = Math.sin(stateTime * 20) * 0.05;
          avatar.position.x = shake;
          avatar.rotation.z = Math.sin(stateTime * 15) * 0.04;
          head.rotation.z = Math.sin(stateTime * 10) * 0.05;
          setEyeOpenness(0.7);
          setBrowMood(1);
          setMouthShape({ width: 0.7, height: 0.4, offsetY: -0.05, rotation: Math.PI });
          bodyMaterial.color.setHex(0xff7b89);
          armMaterial.color.setHex(0xff9aa6);
          leftArm.rotation.z = leftArmBaseRot.z + 0.15;
          rightArm.rotation.z = rightArmBaseRot.z - 0.15;
          break;
        }
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      stateTime += delta;
      updateAnimation(delta);
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>